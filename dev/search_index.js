var documenterSearchIndex = {"docs":
[{"location":"schema/#REST-API","page":"REST","title":"REST API","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"This is an approximate rest API for the PeaceFounder. In future, this will be properly generated and documented from the code. ","category":"page"},{"location":"schema/","page":"REST","title":"REST","text":"GET /deme # returns a current manifest file\nGET /deme/{hash}\n\nPOST /tickets : Tuple{TicketID, DateTime, auth_code::Digest} -> Tuple{salt::Vector{UInt8}, auth_code::Digest} # resets token when repeated\nDELETE /tickets/{TicketID}\nPUT /tickets/{TicketID} : Tuple{Pseudonym, auth_code::Digest} -> Admission\nGET /tickets/{TicketID} : TicketStatus\n\nPOST /braidchain/members : Member -> AckInclusion{ChainState}\nGET /braidchain/members : Vector{Tuple{Int, Member}}\nGET /braidchain/members?id={Pseudonym} : Tuple{Int, Member}\nGET /braidchain/members?pseudonym={Pseudonym} : Tuple{Int, Member}\n\nPOST /braidchain/proposals : Proposal -> AckInclusion\nGET /braidcahin/proposals/{UUID} : Tuple{Int, Proposal}\nGET /braidchain/proposals : Vector{Tuple{Int, Proposal}}\n\nGET /braidchain/{Int}/record : Transaction\nGET /braidchain/{Int}/leaf : AckInclusion{ChainState}\nGET /braidchain/{Int}/root : AckConsistency{ChainState}\nGET /braidchain/commit : Commit{ChainState}\nGET /braidchain/tar : BraidChainArchive\n\nPOST /pollingstation/{UUID}/votes : Vote -> CastAck\nGET /pollingstation/{UUID}/spine : Vector{Digest}\nGET /pollingstation/{UUID}/commit : Commit{BallotBoxState}\nGET /pollingstation/{UUID}/proposal : Tuple{Int, Proposal}\nGET /pollingstation/{UUID}/votes/{Int}/record : CastRecord\nGET /pollingstation/{UUID}/votes/{Int}/receipt : CastReceipt\nGET /pollingstation/{UUID}/votes/{Int}/leaf : AckInclusion{BallotBoxState}\nGET /pollingstation/{UUID}/votes/{Int}/root : AckConsistency{BallotBoxState}\nGET /pollingstation/{UUID}/tar : BallotBoxArchive\nGET /pollingstation/collectors # necessary to make a proposal","category":"page"},{"location":"schema/#Braider","page":"REST","title":"Braider","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"GET /braider : BraiderStatus\nGET /braider/jobs : Vector{JobID}\nGET /braider/jobs/{JobID} : JobStatus\nGET /braider/jobs/{JobID}/braid : Braid\nPOST /braider/jobs : BraidJobSpec -> JobID\nPUT /braider/jobs/{JobID} : Tuple{Vector{Pseudonym}, Generator} -> JobStatus","category":"page"},{"location":"schema/#Admin","page":"REST","title":"Admin","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"Note that at this level I also need to implement authetification. ","category":"page"},{"location":"schema/","page":"REST","title":"REST","text":"POST /admin/ticket : Tuple{Pseudonym, CryptoSpec, token::BigInt} # sets up the guardian\nGET /admin/ticket : Pseudonym\n\nGET /admin/braider : BraiderStatus\nPUT /admin/braider : BraiderCommand -> BraiderStatus\n# restarting process in case of errors\n# setting allowed cryptographic groups\n# making an allowlist or blocklist\n# setting braider key\n\nGET /admin/broker : BraidBrokerStatus\nPUT /admin/broker : BraidBrokerCommand -> BraidBraiderStatus\n# adding a braider location\n# starting brading manually\n# scheduling braiding\n# restarting process in case of errors\n\nGET /admin/dealer : DealerStatus # contains scheduled jobs\nPUT /admin/dealer : DealerCommand -> DealerStatus\n# adding beacon location\n# sending a pulse manually\n# passing lot without pulse\n\nGET /admin/recruiter : RecruiterStatus\nPUT /admin/recruiter : RecruiterCommand -> RecruiterStatus\n# setting a recruiter key\n# sets up a secret key a third party can use to push new forms and retrieve tokens\n\nGET /admin/pollingstation : PollingStationStatus # contains a list of collectors\nPUT /admin/pollingstation : PollingStaionCommand -> PollingStationStatus\n# generates a collector key\n# tally a given proposal manually\n# adding an allowlist for monitors (who gets to backup votes)\n# adding an allowlist for third party collectors who get to submit votes in case of DDOS attack","category":"page"},{"location":"audit/#Audit","page":"Audit","title":"Audit","text":"","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Peacefounder builds upon a knot-like primitive, which we shall call a braid. ","category":"page"},{"location":"model_api/#PeaceFounder.Model","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"","category":"section"},{"location":"model_api/#Crypto-primitives","page":"PeaceFounder.Model","title":"Crypto primitives","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"CurrentModule = PeaceFounder","category":"page"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.canonicalize","category":"page"},{"location":"model_api/#PeaceFounder.Model.canonicalize","page":"PeaceFounder.Model","title":"PeaceFounder.Model.canonicalize","text":"ToDo: a well specified encoding is essential here. Binary tree encoding may suffice here. More fancy approach would be to use a DER encoding. Meanwhile JSON shall be used.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.isbinding","category":"page"},{"location":"model_api/#PeaceFounder.Model.isbinding","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(x, y, spec::Hash)::Bool\nisbinding(x, y, spec) = isbinding(x, y, hasher(spec)::Hash)\n\nCheck binding of two objects x and y. Some general examples:\n\nCheck that a document is bound to it's signature. \nCheck that a record is included in the ledger.\nCheck that a given object is consistent with a ledger.\n\n\n\n\n\nisbinding(ticketid::TicketID, timestamp::DateTime, auth_code::Digest, hmac::HMAC)\n\nCheck whether request for a new ticketid is authorized by recruit client. Note that freshness of the request  is not considered within this method.\n\n\n\n\n\nisbinding(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, auth_code::Digest, hmac::HMAC)\n\nCheck whether a reply for a new ticketid is authorized by the recruit server. \n\n\n\n\n\nisbinding(id::Pseudonym, auth_code::Digest, token::Digest, hasher::Hash)\n\nCheck whether a request for a new identity pseudonym admission is authetificated. The token is delivered to a user by recruit client.\n\n\n\n\n\nisbinding(record::Transaction, ack::AckInclusion{ChainState}, crypto::CryptoSpec)\n\nA generic method checking whether transaction is included in the braidchain.\n\n\n\n\n\nisbinding(admission::Admission, spec::DemeSpec)\n\nCheck whether issuer of admission is a recruiter set in spec.\n\n\n\n\n\nisbinding(chain::BraidChain, state::ChainState)::Bool\n\nCheck that chain state is consistent with braidchain ledger.\n\n\n\n\n\nisbinding(vote::Vote, proposal::Proposal, crypto::CryptoSpec)\n\nCheck that the vote is bound to a proposal.. \n\n\n\n\n\nisbinding(receipt::CastReceipt, ack::AckInclusion, hasher::Hash)::Bool\n\nCheck that cast receipt is binding to received inclusion acknowledgment.\n\n\n\n\n\nisbinding(receipt::CastReceipt, vote::Vote, hasher::Hash)::Bool\n\nCheck that the receipt is bidning to a vote. \n\n\n\n\n\nisbinding(ack::CastAck, proposal::Proposal, hasher::Hash)::Bool\n\nCheck that acknowledgment is legitimate meaning that it is issued by a collector listed in the proposal.\n\n\n\n\n\nisbinding(vote::Vote, ack::CastAck, hasher)\n\nCheck whether acknowledgment is bound to the provided vote.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.CryptoSpec","category":"page"},{"location":"model_api/#PeaceFounder.Model.CryptoSpec","page":"PeaceFounder.Model","title":"PeaceFounder.Model.CryptoSpec","text":"struct CryptoSpec\n    hasher::Hash\n    group::Spec\n    generator::Geenrator\nend\n\nSpecification of cryptographic parameters which are used for public key cryptography, message hashing and authetification codes. \n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.verify","category":"page"},{"location":"model_api/#PeaceFounder.Model.verify","page":"PeaceFounder.Model","title":"PeaceFounder.Model.verify","text":"verify(message, seal::Seal, [generator::Generator], crypto::CryptoSpec)::Bool\nverify(message, pk::Pseudonym, sig::Signature, [generator::Generator], crypto::CryptoSpec)::Bool\n\nVerify the cryptographic signature of the message returning true if valid.  An optional generator can be given when signature is issued on  a relative generator differing from a base specification crypto. \n\n\n\nverify(document[, generator::Generator], crypto::CryptoSpec)::Bool\n\nVerify a cryptographic signature of the document returning true if valid. \n\n\n\nverify(braidwork::BraidWork, crypto::CryptoSpec)::Bool\n\nVerify a braider issued cryptographic signature for the braidwork and a zero knowledge proofs. Returns true if both checks succeed.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Pseudonym","category":"page"},{"location":"model_api/#PeaceFounder.Model.Pseudonym","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Pseudonym","text":"struct Pseudonym\n    pk::Vector{UInt8}\nend\n\nA datatype which stores public key in canonical standart octet form.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.pseudonym","category":"page"},{"location":"model_api/#PeaceFounder.Model.pseudonym","page":"PeaceFounder.Model","title":"PeaceFounder.Model.pseudonym","text":"pseudonym(signer::Signer, [generator])::Pseudonym\n\nReturn a pseudonym of a signer at a given relative generator. If generator is not passed returns identity pseudonym. (See also id)\n\n\n\npseudonym(seal::Seal)::Pseudonym\n\nReturn a pseudonym of a seal. Note that it is not equal to identity when the signature is issued on a relative generator.\n\n\n\npseudonym(vote::Vote)::Pseudonym\n\nReturn a pseudonym used to seal the vote.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.id","category":"page"},{"location":"model_api/#PeaceFounder.Model.id","page":"PeaceFounder.Model","title":"PeaceFounder.Model.id","text":"id(document)::Pseudonym\n\nReturn identity pseudonym of a document issuer.\n\n\n\nid(signer)::Pseudonym\n\nReturn identity pseudonym of a signer.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.issuer","category":"page"},{"location":"model_api/#PeaceFounder.Model.issuer","page":"PeaceFounder.Model","title":"PeaceFounder.Model.issuer","text":"issuer(x)\n\nIn case an object x is cryptographically signed return an issuer of who have issued the signature. See also id.\n\n\n\n\n\nissuer(member::Member)::Pseudonym\n\nThe identiy of registrar who signed admission.\n\n\n\n\n\nissuer(proposal::Proposal)\n\nIssuer of approval for the proposal.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Generator","category":"page"},{"location":"model_api/#PeaceFounder.Model.Generator","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Generator","text":"struct Generator\n    data::Vector{UInt8}\nend\n\nDatatype which stores cryptogrpahic group point in standart octet form intended to be used as a base. See also Pseudonym.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.generator","category":"page"},{"location":"model_api/#PeaceFounder.Model.generator","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(spec::Spec)::Generator\n\nReturn a generator of spec.\n\n\n\n\n\ngenerator(crypto::CryptoSpec)::Generator\n\nReturn a generator of the specification. \n\n\n\n\n\ngenerator(ledger::BraidChain)\n\nReturn a current relative generator for a braidchain ledger.\n\n\n\n\n\ngenerator(ledger[, index])\n\nReturn a generator at braidchain ledger row index. If index is omitted return the current state value.\n\n\n\n\n\ngenerator(member::Member)::Generator\n\nGenerator at which member tries to roll in the braidchain.\n\n\n\n\n\ngenerator(proposal::Proposal)\n\nA relative generator for at which memebers sign votes for this proposal.\n\n\n\n\n\ngenerator(ledger::BallotBox)\n\nReturn a relative generator which members use to sign votes anchored by the proposal.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Hash","category":"page"},{"location":"model_api/#PeaceFounder.Model.Hash","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Hash","text":"struct Hash\n    spec::String\nend\n\nA specification for a hasher. See method digest.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.hasher","category":"page"},{"location":"model_api/#PeaceFounder.Model.hasher","page":"PeaceFounder.Model","title":"PeaceFounder.Model.hasher","text":"hasher(spec)::Hash\n\nAccess a hasher function from a given specification.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Digest","category":"page"},{"location":"model_api/#PeaceFounder.Model.Digest","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Digest","text":"struct Digest\n    data::Vector{UInt8}\nend\n\nA message digest obtained applying a hash function on a message or a document. See method digest.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.digest","category":"page"},{"location":"model_api/#PeaceFounder.Model.digest","page":"PeaceFounder.Model","title":"PeaceFounder.Model.digest","text":"digest(bytes::Vector{UInt8}, hasher::Hash)::Digest\ndigest(x, spec) = digest(canonicalize(x)::Vector{UInt8}, hasher(spec)::Hash)\n\nCompute a hash digest. When input is not in bytes the canonicalize method is applied first.\n\n\n\n\n\ndigest(message::Vector{UInt8}, hasher::Hash)::Digest\ndigest(document, spec) = digest(canonicalize(message)::Vector{UInt8}, hasher(spec)::Hash)\n\nReturn a resulting digest applying hasher on the given message. When message is not octet string a canonicalize method is applied first.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Signer","category":"page"},{"location":"model_api/#PeaceFounder.Model.Signer","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Signer","text":"struct Signer\n    spec::CryptoSpec\n    pbkey::Pseudonym\n    key::BigInt\nend\n\nA signer type. See a method generate(Signer, spec) for initialization.\n\nInterface: pseudonym, id, sign, seal, approve\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.sign","category":"page"},{"location":"model_api/#PeaceFounder.Model.sign","page":"PeaceFounder.Model","title":"PeaceFounder.Model.sign","text":"sign(message::Vector{UInt8}[, generator::Generator], signer::Signer)::Signature\n\nSign a bytestring message with signer's private key and specification. When generator is provided it is used as  a base for the signature.\n\n\n\n\n\nsign(digest::Digest[, generator::Generator], signer::Signer)::Signature\n\nSign a digest as an integer with signer's private key and specification. This method avoids  running hashing twice when that is done externally. When generator is provided it is used as  a base for the signature.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.generate","category":"page"},{"location":"model_api/#PeaceFounder.Model.generate","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generate","text":"generate(Signer, spec::CryptoSpec)::Signer\n\nGenerate a unique private key and return a Signer object. \n\n\n\n\n\ngenerate(TokenRecruiter, spec::CryptoSpec)\n\nGenerate a new token recruiter with unique signer and athorization key.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Seal","category":"page"},{"location":"model_api/#PeaceFounder.Model.Seal","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Seal","text":"struct Seal\n    pbkey::Pseudonym\n    sig::Signature\nend\n\nA wrapper type for a signature which adds a public key of signature issuer. See seal method. \n\nInterface: pseudonym, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.seal","category":"page"},{"location":"model_api/#PeaceFounder.Model.seal","page":"PeaceFounder.Model","title":"PeaceFounder.Model.seal","text":"seal(message::Vector{UInt8}[, generator::Generator], signer::Signer)::Seal\n\nSign a bytestring message with signer's private key and specification and return a signature as a Seal. When generator is provided it is used as  a base for the signature. See also sign.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.approve","category":"page"},{"location":"model_api/#PeaceFounder.Model.approve","page":"PeaceFounder.Model","title":"PeaceFounder.Model.approve","text":"approve(x::T, signer::Signer)::T\n\nCryptographically sign a document x::T and returns a signed document with the same type. To check whether a document is signed see issuer method.\n\n\n\n\n\napprove(member::Member, signer::Signer)::Member\n\nSign a member certificate and return it with approval field filled.\n\n\n\n\n\napprove(braid::BraidWork, braider::Signer)\n\nSign a braidwork with a braider. Throws an error if braider is not in the producer demespec.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Commit","category":"page"},{"location":"model_api/#PeaceFounder.Model.Commit","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Commit","text":"Commit{T}\n    state::T\n    seal::Seal\nend\n\nRepresents a commited ledger state to which issuer can be held accountable for integrity. It is assumed that T implements index and root necessaary to fix a ledger state. \n\nInterface: id, issuer, verify, index, root, state\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.index","category":"page"},{"location":"model_api/#PeaceFounder.Model.index","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(x)::Int\n\nReturn an index of a ledger state.\n\n\n\n\n\nindex(ack::AckInclusion)::Int\n\nReturn an index at which the leaf is recorded in the ledger. To obtain the current ledger index use index(commit(ack)).\n\n\n\n\n\nindex(ack::AckConsistency)\n\nReturn an index for a root at which the consistency proof is made. To obtain the current ledger index use index(commit(ack)).\n\n\n\n\n\nindex(state::BallotBoxState)\n\nReturn an index for a current ballotbox ledger state.\n\n\n\n\n\nindex(ledger::BallotBox)\n\nReturn the current index of the ledger. See also length.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.root","category":"page"},{"location":"model_api/#HistoryTrees.root","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(x)::Digest\n\nReturn a ledger root hash.\n\n\n\n\n\nroot(x::AckConsistency)\n\nAccess a root diggest for which the acknowledgment is made.\n\n\n\n\n\nroot(ledger::BraidChain[, N::Int])::Digest\n\nReturn a ledger root digest. In case when index is not given a current index is used.\n\n\n\n\n\nroot(state::BallotBoxState)\n\nReturn a history tree root for a current ballotbox ledger state.\n\n\n\n\n\nroot(ledger::BallotBox[, N::Int])::Digest\n\nCalculate a root for history tree at given index N. If index is not specified returns the current value.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.state","category":"page"},{"location":"model_api/#PeaceFounder.Model.state","page":"PeaceFounder.Model","title":"PeaceFounder.Model.state","text":"state(commit::Commit{T})::T\n\nReturn a ledger state. T implements index and root. \n\n\n\n\n\nstate(ledger::BraidChain)\n\nReturn a current braidchain ledger state metadata.\n\n\n\n\n\nstate(proposal::Proposal)::ChainState\n\nA braidchain ledger state which is used to anchor a relative generator for members.\n\n\n\n\n\nstate(ledger::BallotBox; with_tally::Union{Nothing, Bool} = nothing)::BallotBoxState\n\nReturn a state metadata for ballotbox ledger. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.AckInclusion","category":"page"},{"location":"model_api/#PeaceFounder.Model.AckInclusion","page":"PeaceFounder.Model","title":"PeaceFounder.Model.AckInclusion","text":"struct AckInclusion{T}\n    proof::InclusionProof\n    commit::Commit{T}\nend\n\nRepresents an acknowldgment from the issuer that a leaf is permanently included in the ledger.  In case the ledger is tampered with this acknowledgement acts as sufficient proof to blame the issuer.\n\nInterface: leaf, id, issuer, commit, index, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.leaf","category":"page"},{"location":"model_api/#HistoryTrees.leaf","page":"PeaceFounder.Model","title":"HistoryTrees.leaf","text":"leaf(ack::AckInclusion)\n\nAccess a leaf diggest for which the acknowledgment is made.\n\n\n\n\n\nleaf(ledger::BraidChain, N::Int)::Digest\n\nReturn a ledger's element digest at given index.\n\n\n\n\n\nleaf(ledger::BallotBox, N::Int)::Digest\n\nReturn a record digest used to form a history tree.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.AckConsistency","category":"page"},{"location":"model_api/#PeaceFounder.Model.AckConsistency","page":"PeaceFounder.Model","title":"PeaceFounder.Model.AckConsistency","text":"struct AckConsistency{T}\n    proof::ConsistencyProof\n    commit::Commit{T}\nend\n\nRepresents an ackknowledgment from the issuer that a root is permanetly included in the ledger. This acknowledgemnt assures that ledger up to index(ack) is included in the current ledger which has has index index(commit(ack)). This is useful in a combination with AckInclusion to privatelly update it's validity rather than asking an explicit element. Also ensures that other elements in the ledger are not being tampered with.\n\nInterface: root, id, issuer, commit, index, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.commit","category":"page"},{"location":"model_api/#PeaceFounder.Model.commit","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(x)\n\nAccess a commit of an object x. \n\n\n\n\n\ncommit(ledger::BraidChain)\n\nReturn a current commit for a braichain. \n\n\n\n\n\ncommit(ack::CastAck)\n\nReturn a commit from a CastAck.\n\n\n\n\n\ncommit(ledger::BallotBox)\n\nReturn a commit for the ballotbox ledger.\n\n\n\n\n\ncommit(station::PollingStation, uuid::UUID)::Commit\n\nReturn a ballotbox commit.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.HMAC","category":"page"},{"location":"model_api/#PeaceFounder.Model.HMAC","page":"PeaceFounder.Model","title":"PeaceFounder.Model.HMAC","text":"struct HMAC\n    key::Vector{UInt8}\n    hasher::Hash\nend\n\nRepresent a hash message authetification code authorizer.\n\nInterface: hasher, digest, key\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.key","category":"page"},{"location":"model_api/#PeaceFounder.Model.key","page":"PeaceFounder.Model","title":"PeaceFounder.Model.key","text":"key(x)\n\nAccess a secret key of an object x.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.hmac","category":"page"},{"location":"model_api/#Recruitment","page":"PeaceFounder.Model","title":"Recruitment","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.TicketID","category":"page"},{"location":"model_api/#PeaceFounder.Model.TicketID","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TicketID","text":"struct TicketID\n    id::Vector{UInt8}\nend\n\nRepresents a unique identifier for which a recruit tooken is issued. In case of necessity id can contain a full document, for instance, registration form, proof of identity and etc. In case a privacy is an issue the id can contain a unique identifier which can be matched to an identity in an external database.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Admission","category":"page"},{"location":"model_api/#PeaceFounder.Model.Admission","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Admission","text":"struct Admission\n    ticketid::TicketID\n    id::Pseudonym\n    timestamp::DateTime\n    approval::Union{Seal, Nothing}\nend\n\nRepresents an admission certificate for a pseudonym id. \n\nInterface: approve, issuer, id, ticket, isadmitted\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.ticket","category":"page"},{"location":"model_api/#PeaceFounder.Model.ticket","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ticket","text":"ticket(x::Admission)\n\nReturn a TicketID which is admitted.\n\n\n\n\n\nticket(member::Member)\n\nTicket for a member admission certificate.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Ticket","category":"page"},{"location":"model_api/#PeaceFounder.Model.Ticket","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Ticket","text":"mutable struct Ticket\n    const ticketid::TicketID\n    timestamp::DateTime\n    salt::Vector{UInt8}\n    auth_code::Digest\n    token::Digest\n    admission::Union{Admission, Nothing}\nend\n\nRepresents a ticket state for ticket with ticketid. timestamp represents time when the ticket have been issued by a recruiter client in authorization system of choice, for instance, Recruiters.jl; salt contains a random bytestring generated by the server from which the reccruiter client can derive a token as token(ticketid, salt, hmac). auth_code is a server generated authetification code for a given salt and current metadata. Lastly admission contains a certified member pseudonym which was authetificated by the user with token.\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.TokenRecruiter","category":"page"},{"location":"model_api/#PeaceFounder.Model.TokenRecruiter","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TokenRecruiter","text":"struct TokenRecruiter\n    metadata::Ref{Vector{UInt8}} \n    tickets::Vector{Ticket}\n    signer::Signer\n    hmac::HMAC\nend\n\nRepresents a state for token recruiter service. To initialize the service it's necessary to create a signer who can issue a valid admisssion certificates and a secret key with which a recruit client can exchange authorized messages. See also method generate(TokenRecruiter, spec).\n\nMetadata is used as means to securelly deliver to the client most recent server specification. \n\nInterface: select, hmac, hasher, key, id, tickets, in, set_metadata!, enlist!, admit!, isadmitted, ticket_status\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"Base.in","category":"page"},{"location":"model_api/#Base.in","page":"PeaceFounder.Model","title":"Base.in","text":"in(ticketid::TicketID, recruiter::TokenRecruiter)::Bool\n\nReturn true if there already is a ticket with ticketid.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.set_metadata!","category":"page"},{"location":"model_api/#PeaceFounder.Model.set_metadata!","page":"PeaceFounder.Model","title":"PeaceFounder.Model.set_metadata!","text":"set_metadata!(recruiter::TokenRecruiter, metadata::Vector{UInt8})\n\nReplace metadata for a recruiter. Note when data is replaced all unfinalized tokens need to be flushed. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.select","category":"page"},{"location":"model_api/#PeaceFounder.Model.select","page":"PeaceFounder.Model","title":"PeaceFounder.Model.select","text":"select(T, predicate::Function, recruiter::TokenRecruiter)::Union{T, Nothing}\n\nFrom a list of all recruiter tickets return T <: Union{Ticket, Admission} for which predicate is true. If none succeds returns nothing.\n\n\n\n\n\nselect(Admission, ticketid::TicketID, recruiter::TokenRecruiter)::Union{Admission, Nothing}\n\nReturn admission for a ticket with given ticketid from recruiter. If no ticket with given ticketid is found OR ticket is not yet admitted returns nothing.\n\n\n\n\n\nselect(Admission, ticketid::TicketID, recruiter::TokenRecruiter)::Union{Admission, Nothing}\n\nReturn admission for a ticket with given a given identity pseudonym from recruiter. If no ticket with given id is found OR ticket is not yet admitted returns nothing.\n\n\n\n\n\nselect(T, predicate::Function, ledger::BraidChain)::Union{T, Nothing}\n\nReturn a first element from a ledger with a type T which satisfies a predicate. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.tickets","category":"page"},{"location":"model_api/#PeaceFounder.Model.tickets","page":"PeaceFounder.Model","title":"PeaceFounder.Model.tickets","text":"tickets(recruiter::TokenRecruiter)::Vector{TicketID}\n\nReturn a list of registered ticket ids. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.auth","category":"page"},{"location":"model_api/#PeaceFounder.Model.auth","page":"PeaceFounder.Model","title":"PeaceFounder.Model.auth","text":"auth(ticketid::TicketID, time::DateTime, hmac::HMAC)::Digest\n\nCompute a hash authorization code for ticketid at given time. The message needs to reach token recruiter within a 60 second window before it is obseleted.\n\n\n\n\n\nauth(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)::Digest\n\nCompute a hash authorization code for a metadata, salt from which a token is derived. Metadata can be configured to contain most recent server specification DemeSpec; ticketid takes session identifier role.\n\n\n\n\n\nauth(id::Pseudonym, hmac::HMAC)::Digest\nauth(id::Pseudonym, token::Digest, hasher::Hash) = auth(id, HMAC(bytes(token), hasher))\n\nCompute a hash authorization code for identity pseudonym using token as a key. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.token","category":"page"},{"location":"model_api/#PeaceFounder.Model.token","page":"PeaceFounder.Model","title":"PeaceFounder.Model.token","text":"token(ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)\n\nCompute a recruit token for a given ticket with provided salt. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.enlist!","category":"page"},{"location":"model_api/#PeaceFounder.Model.enlist!","page":"PeaceFounder.Model","title":"PeaceFounder.Model.enlist!","text":"enlist!(recruiter::TokenRecruiter, ticketid::TicketID, timestamp::DateTime, ticket_auth_code::Digest)::Tuple{Vector{UInt8}, Vector{UInt8}, Digest}\n\nAttempt to enlist a ticket with given ticketid authetificated by a recruit client at timestmap. This function checks the age of the request which need to be less than 60 seconds to be considered. Then the hash authorization code is checked after which a triplet of metadata, salt and reply_auth_code is returned. If either of theses checks fail an error is raised and needs to be dealt by the user. See a token method on how the token is derived.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.admit!","category":"page"},{"location":"model_api/#PeaceFounder.Model.admit!","page":"PeaceFounder.Model","title":"PeaceFounder.Model.admit!","text":"admit!(recruiter::TokenRecruiter, id::Pseudonym, ticketid::TicketID, auth_code::Digest)::Admission\n\nAttempt to admit an identity pseudonym id for ticket ticketid with provided authorization code. This function retrieves a ticket with given ticketid and uses it's recorded token to check whether the request is binding. In the case of success an admnission certificate is formed with provided indenty pseudonym id and is signed by the recruter's private key. Otherwise when either of checks fail an error is raised. In the case ticket is already addmitted, returns previously stored admission. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.isadmitted","category":"page"},{"location":"model_api/#PeaceFounder.Model.isadmitted","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isadmitted","text":"isadmitted(ticketid::TicketID, recruiter::TokenRecruiter)\n\nCheck whether a ticket is already admitted. Returns false when either ticket is nonexistent or it's admission is nothing.\n\n\n\n\n\nisadmitted(status::TicketStatus)\n\nCheck whether ticket is addmitted. \n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.TicketStatus","category":"page"},{"location":"model_api/#PeaceFounder.Model.TicketStatus","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TicketStatus","text":"struct TicketStatus     ticketid::TicketID     timestamp::DateTime     admission::Union{Nothing, Admission} end\n\nRepresents a public state of a ticket. See ticket_status and isadmitted methods. \n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.ticket_status","category":"page"},{"location":"model_api/#PeaceFounder.Model.ticket_status","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ticket_status","text":"ticket_status(ticketid::TicketID, recruiter::TokenRecruiter)::Union{TicketStatus, Nothing}\n\nReturn a ticket status for a ticketid. In case ticket is not found return nothing.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.hmac","category":"page"},{"location":"model_api/#PeaceFounder.Model.hmac","page":"PeaceFounder.Model","title":"PeaceFounder.Model.hmac","text":"hmac(x)::HMAC\n\nReturn HMAC authorizer from a given object.\n\n\n\n\n\n","category":"function"},{"location":"model_api/#BraidChain","page":"PeaceFounder.Model","title":"BraidChain","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.Transaction","category":"page"},{"location":"model_api/#PeaceFounder.Model.Transaction","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Transaction","text":"Represents an abstract record type which can be stored in the braidchain ledger. \n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.DemeSpec","category":"page"},{"location":"model_api/#PeaceFounder.Model.DemeSpec","page":"PeaceFounder.Model","title":"PeaceFounder.Model.DemeSpec","text":"struct DemeSpec <: Transaction\n    uuid::UUID\n    title::String\n    crypto::CryptoSpec\n    guardian::Pseudonym\n    recorder::Pseudonym\n    recruiter::Pseudonym\n    braider::Pseudonym\n    proposer::Pseudonym \n    collector::Pseudonym\n    timestamp::Union{DateTime, Nothing} = nothing\n    signature::Union{Signature, Nothing} = nothing\nend\n\nRepresents a deme configuration parameters issued by the guardian.\n\nuuid::UUID an unique random generated community identifier;\ntitle::String a community name with which deme is represented;\ncrypto::CryptoSpec cryptographic parameters for the deme;\nguardian::Pseudonym an issuer for this demespec file. Has authorithy to set a roster:\nrecorder::Pseudonym an authorithy which has rights to add new transactions and is responsable for braidchain's ledger integrity. Issues Commit{ChainState};\nrecruiter::Pseudonym an authorithy which has rights to authorize new admissions to the deme. See Admission and Member;\nbraider::Pseudonym an authorithy which can do a legitimate braid jobs for other demes. See BraidWork;   \nproposer::Pseudonym an authorithy which has rights to issue a proposals for the braidchain. See Proposal;\ncollector::Pseudonym an authorithy which is repsonsable for collecting votes for proposals. This is also recorded in the proposal itself.\ntimestamp::Union{DateTime, Nothing} time when signature is being issued;\nsignature::Union{Signature, Nothing} a guardian issued signature. \n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.ChainState","category":"page"},{"location":"model_api/#PeaceFounder.Model.ChainState","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ChainState","text":"struct ChainState\n    index::Int\n    root::Digest\n    generator::Generator\n    member_count::Int\nend\n\nRepresents a chain state metadata which is sufficient for integrity checks.\n\nInterface: index, root, generator\n\n\n\n\n\n","category":"type"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.BraidChain","category":"page"},{"location":"model_api/#PeaceFounder.Model.BraidChain","page":"PeaceFounder.Model","title":"PeaceFounder.Model.BraidChain","text":"struct BraidChain\n    members::Set{Pseudonym}\n    ledger::Vector{Transaction}\n    spec::DemeSpec\n    generator::Generator\n    tree::HistoryTree\n    commit::Union{Commit{ChainState}, Nothing}\nend\n\nRepresents a braidchain ledger with it's associated state. Can be instantitated with a demespec file using BraidChain(::DemeSpec) method.\n\nInterface:  push!, record!, state, length, list, select, roll, constituents, generator, commit, commit_index, ledger, leaf, root, ack_leaf, ack_root, members, commit!\n\n\n\n\n\n","category":"type"},{"location":"#PeaceFounder.jl","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"","category":"section"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"(Image: ) (Image: ) With the advancement of technology, remote electronic voting systems are becoming more prevalent in many contexts. Often the e-voting systems are designed as a two-step process where in the first step, voters cast encrypted votes, and, in the second step, the encrypted ballots are shuffled between different independent parties for anonymity and then decrypted. However, in these systems' privacy, transparency, and security remain in tension. Making all evidence public would violate the right of voters to keep their decision to participate secret, whereas including more parties who collectively decrypt the votes to ensure the anonymity of the voters could open adversaries an opportunity to prevent the election result from being decrypted or to assemble the entire decryption key providing means to know how exactly each voter had voted. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"An alternative approach is to anonymise voters instead of votes who cast them with a pseudonym. So far, proposed systems have focused on one-time large-scale elections where the relative generator is predetermined at the registration phase. That reduces complexity for the voter but puts a burden on the election authority to coordinate honest execution of re-encryption shuffle and threshold decryption between all involved parties. Although honesty of execution is guaranteed with zero-knowledge proofs, it does not prevent adversary-sabotaged communication issues. Thus, some baseline of trust is necessary for mixes to guarantee the reliability of the mix phase. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"PeaceFounder system differs from existing solutions by doing public key anonymisation for one mix at a time, after which the relative generator, zero-knowledge shuffle, and decryption proofs are published to the bulletin board. Since there is no coordination between mixes, it makes the protocol more reliable. It is important to note that this also makes the anonymisation easier to understand and more accessible to a broader audience as the mixing procedure is local and can be viewed as a function braid(generator, members) -> (new_generator, new_members) that can be visually represented as a knot-tying together multiple threads.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"The PeaceFounder system demonstrates the feasibility of continuously enrolling new members who are anonymised equally with other members in subsequent mixings. The bulletin board is implemented as a Merkle tree where every new member, braid and proposal are recorded in a ledger, forming a transactional database available to everyone to verify. The clients are thin and use Merkle tree inclusion proofs to assert their membership and to get proof that an election authority provides a given proposal and can be held accountable for its correctness, including the relative generator with which the votes are being cast. To assert the integrity of the bulletin board, the clients would periodically download Merkle consistency proofs from the election authority.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"One of the significant advantages of the PeaceFounder system over existing solutions is that a single person can deploy and maintain this system without compromising privacy, security or transparency. It does not rely on the trust of the honest execution of the ceremony for the setup parameters as it is with some cryptocurrency systems, nor does the need to coordinate correct threshold decryption between multiple parties as needed for a re-encryption-based mixnet voting system. This makes it more accessible to smaller communities which want to offer strong software-independent evidence to everyone and assure the members that their vote is anonymous, guaranteed with multiple braids made in different geographical locations.  ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"In addition to existing e-voting solutions, PeaceFounder is made with integration in mind. It's easy (when that will be documented) to use it in existing community webpages or forums, which have their own ways of selecting and authenticating members. Also, it is easy for the administrator to design procedures in which proposals get accepted for the members to vote and display the progress of the current and past proposals as they are being run. Even more unlimited options to design preferential cardinal or budget-constrained ballots are available while ensuring that election evidence provides software independence for everyone. Meanwhile, the votes are cast within a client GUI application offering security and privacy guarantees for the voters. In summary, if you use an e-voting solution on a website, you will benefit from transparency, security and privacy by using PeaceFounder with little to lose in usability. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"PeaceFounder system relies on established ElGamal re-encryption mixnet zero-knowledge proof of shuffle and digital signature algorithm. On top of that, it is assumed that an anonymous communication channel that prevents tracking by IP address is available. Thus a list of assumptions are:","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"DDH hard ensuring computational anonymity;\nInfeasible to do a discrete logarithm;\nAnonymous channel over which to cast a vote;\nWhen evidence of misbehaving election authority is collected/presented, adequate local actions select a new replacement.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"The PeaceFounder system is implemented in Julia with a client user interface written in QML and is available under Apache 2 license on GitHub. Currently, the system is demonstrated as a technical preview intended to test the usability of a happy path. Nevertheless, digital signatures are implemented in CryptoSignatures.jl complies with FIPS standards and re-encryption proof of shuffle is implemented in ShuffleProofs.jl complies with the Verificatum verifier. A proper specification for proof of correct decryption with a single party and canonicalisation of signed data is missing and will be fixed in the future. ","category":"page"},{"location":"#Demo","page":"PeaceFounder.jl","title":"Demo","text":"","category":"section"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"For a demo, go to PeaceFounderDemo repository. A 10-minute youtube demonstration is available here:","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"(Image: IMAGE ALT TEXT HERE)","category":"page"},{"location":"setup/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"A setup will be written here. ","category":"page"}]
}
