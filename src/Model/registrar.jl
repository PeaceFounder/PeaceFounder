import Random
using URIs

# One could add expiration policy and etc. Currently that is not needed.

"""
    mutable struct Ticket
        const ticketid::TicketID
        timestamp::DateTime
        salt::Vector{UInt8}
        auth_code::Digest
        token::Digest
        admission::Union{Admission, Nothing}
    end

Represents a ticket state for ticket with `ticketid`. `timestamp` represents time when the ticket have been issued by a recruiter client in authorization system of choice, for instance, Recruiters.jl; `salt` contains a random bytestring generated by the server from which the reccruiter client can derive a `token` as `token(ticketid, salt, hmac)`. `auth_code` is a server generated authetification code for a given `salt` and current metadata. Lastly `admission` contains a certified member pseudonym which was authetificated by the user with `token`.
"""
mutable struct Ticket
    const ticketid::TicketID
    timestamp::DateTime
    salt::Vector{UInt8}
    auth_code::Digest
    token::Digest
    admission::Union{Admission, Nothing}
end

isadmitted(ticket::Ticket) = !isnothing(ticket.admission)

"""
    struct Registrar
        metadata::Ref{Vector{UInt8}} 
        tickets::Vector{Ticket}
        signer::Signer
        hmac::HMAC
    end

Represents a state for token recruiter service. To initialize the service it's necessary to create a signer who can issue a valid admisssion certificates and a secret key with which a recruit client can exchange authorized messages. See also method `generate(Registrar, spec)`.

Metadata is used as means to securelly deliver to the client most recent server specification. 

**Interface:** [`select`](@ref), [`hmac`](@ref), [`hasher`](@ref), [`key`](@ref), [`id`](@ref), [`tickets`](@ref), [`in`](@ref), [`set_metadata!`](@ref), [`enlist!`](@ref), [`admit!`](@ref), [`isadmitted`](@ref), [`ticket_status`](@ref)
"""
struct Registrar
    metadata::Ref{Vector{UInt8}} # A piece of information which is passed with hmac 
    tickets::Vector{Ticket}
    signer::Signer
    hmac::HMAC
end

Registrar(signer::Signer, hmac::HMAC) = Registrar(Ref{Vector{UInt8}}(UInt8[]), Ticket[], signer, hmac)
Registrar(signer::Signer, key::Vector{UInt8}) = Registrar(Ref{Vector{UInt8}}(UInt8[]), Ticket[], signer, HMAC(key, hasher(signer)))


"""
    generate(Registrar, spec::CryptoSpec)

Generate a new token recruiter with unique signer and athorization key.
"""
function generate(::Type{Registrar}, spec::CryptoSpec)

    key = rand(Random.RandomDevice(), UInt8, 32) # Alternativelly I could derive it from a global SEED
    recruiter = generate(Signer, spec)

    return Registrar(recruiter, key)
end

"""
    hmac(x)::HMAC

Return HMAC authorizer from a given object.
"""
hmac(recruiter::Registrar) = recruiter.hmac
hasher(recruiter::Registrar) = hasher(hmac(recruiter))
key(recruiter::Registrar) = key(hmac(recruiter))
id(recruiter::Registrar) = id(recruiter.signer)


"""
    select(T, predicate::Function, recruiter::Registrar)::Union{T, Nothing}

From a list of all `recruiter` tickets return `T <: Union{Ticket, Admission}` for which predicate is true. If none succeds returns nothing.
"""
function select(::Type{Ticket}, f::Function, recruiter::Registrar)
    
    for i in recruiter.tickets
        if f(i) == true
            return i
        end
    end
    
    return nothing
end

select(::Type{Ticket}, ticketid::TicketID, recruiter::Registrar) = select(Ticket, i -> i.ticketid == ticketid, recruiter)

select(::Type{Admission}, f::Function, recruiter::Registrar) = select(Ticket, f, recruiter).admission

"""
    select(Admission, ticketid::TicketID, recruiter::Registrar)::Union{Admission, Nothing}

Return admission for a ticket with given `ticketid` from `recruiter`. If no ticket with given `ticketid` is found OR ticket is not yet admitted returns nothing.
"""
select(::Type{Admission}, ticketid::TicketID, recruiter::Registrar) = select(Admission, i -> i.ticketid == ticketid, recruiter)

"""
    select(Admission, ticketid::TicketID, recruiter::Registrar)::Union{Admission, Nothing}

Return admission for a ticket with given a given identity pseudonym from `recruiter`. If no ticket with given `id` is found OR ticket is not yet admitted returns nothing.
"""
select(::Type{Admission}, id::Pseudonym, recruiter::Registrar) = select(Admission, i -> isnothing(i) ? false : i.admission.id == id, recruiter::Registrar)



# Need to refactor it into select

using Base64: base64encode # an alternative would be to do base64decode on credential

function get_ticket(registrar::Registrar, tokenid::AbstractString)

    for ticket in registrar.tickets
        if digest(bytes(ticket.token), hasher(registrar)) |> bytes |> base64encode == tokenid
            return ticket
        end
    end

    error("Ticket not found")
end

#get_ticket(tokenid::AbstractString) = get_ticket(Mapper.REGISTRAR[], tokenid)






ticket_ids(recruiter::Registrar) = tickets(recruiter)

"""
    tickets(recruiter::Registrar)::Vector{TicketID}

Return a list of registered ticket ids. 
"""
tickets(recruiter::Registrar) = (i.ticketid for i in recruiter.tickets)

"""
    in(ticketid::TicketID, recruiter::Registrar)::Bool

Return true if there already is a ticket with `ticketid`.
"""
Base.in(ticketid::TicketID, recruiter::Registrar) = ticketid in ticket_ids(recruiter)

# I will need to add also a date to avoid creation of old tickets

bytes(time::DateTime) = reinterpret(UInt8, [time.instant.periods.value])

"""
    auth(ticketid::TicketID, time::DateTime, hmac::HMAC)::Digest

Compute a hash authorization code for `ticketid` at given `time`. The message needs to reach token recruiter within a 60 second window before it is obseleted.
"""
auth(ticketid::TicketID, time::DateTime, hmac::HMAC) = digest(UInt8[1, bytes(ticketid)..., bytes(time)...], hmac)

"""
    auth(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)::Digest

Compute a hash authorization code for a `metadata`, `salt` from which a token is derived. Metadata can be configured to contain most recent server specification `DemeSpec`; `ticketid` takes session identifier role.
"""
auth(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC) = digest(UInt8[2, metadata..., bytes(ticketid)..., salt...], hmac)

"""
    token(ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)

Compute a recruit token for a given ticket with provided `salt`. 
"""
token(ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC) = digest(UInt8[0, bytes(ticketid)..., salt...], hmac)
token(ticket::Ticket, hmac::HMAC) = token(ticket.ticketid, ticket.salt, hmac)


"""
    auth(id::Pseudonym, hmac::HMAC)::Digest
    auth(id::Pseudonym, token::Digest, hasher::Hash) = auth(id, HMAC(bytes(token), hasher))

Compute a hash authorization code for identity pseudonym using `token` as a key. 
"""
auth(id::Pseudonym, hmac::HMAC) = digest(bytes(id), hmac)
auth(id::Pseudonym, token::Digest, hasher::Hash) = auth(id, HMAC(bytes(token), hasher))


"""
    isbinding(ticketid::TicketID, timestamp::DateTime, auth_code::Digest, hmac::HMAC)

Check whether request for a new ticketid is authorized by recruit client. Note that freshness of the request 
is not considered within this method.
"""
isbinding(ticketid::TicketID, time::DateTime, auth_code::Digest, hmac::HMAC) = auth(ticketid, time, hmac) == auth_code

"""
    isbinding(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, auth_code::Digest, hmac::HMAC)

Check whether a reply for a new ticketid is authorized by the recruit server. 
"""
isbinding(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, auth_code::Digest, hmac::HMAC) = auth(metadata, ticketid, salt, hmac) == auth_code

"""
    isbinding(id::Pseudonym, auth_code::Digest, token::Digest, hasher::Hash)

Check whether a request for a new identity pseudonym admission is authetificated. The token is delivered to a user by recruit client.
"""
isbinding(id::Pseudonym, auth_code::Digest, token::Digest, hasher::Hash) = auth(id, token, hasher) == auth_code

"""
    set_metadata!(recruiter::Registrar, metadata::Vector{UInt8})

Replace metadata for a recruiter. Note when data is replaced all unfinalized tokens need to be flushed. 
"""
set_metadata!(recruiter::Registrar, metadata::Vector{UInt8}) = recruiter.metadata[] = metadata


# """
#     enlist!(recruiter::Registrar, ticketid::TicketID, timestamp::DateTime, ticket_auth_code::Digest)::Tuple{Vector{UInt8}, Vector{UInt8}, Digest}

# Attempt to enlist a ticket with given `ticketid` authetificated by a recruit client at `timestmap`. This function checks
# the age of the request which need to be less than 60 seconds to be considered. Then the hash authorization code is checked after which a triplet of `metadata`, `salt` and `reply_auth_code` is returned. If either of theses checks fail an error is raised and needs to be dealt by the user. See a [`token`](@ref) method on how the token is derived.
# """
# function enlist!(recruiter::Registrar, ticketid::TicketID, timestamp::DateTime, ticket_auth_code::Digest)
   
#     @assert (Dates.now() - timestamp) < Second(3600) "Old request"

#     @assert isbinding(ticketid, timestamp, ticket_auth_code, hmac(recruiter)) # need to be aware of replay attack and bouncing back

#     for ticket in recruiter.tickets
#         if ticket.ticketid == ticketid
#             return recruiter.metadata[], ticket.salt, ticket.auth_code
#         end
#     end
    
#     salt = rand(UInt8, 16) # Needs a real random number generator
#     _token = token(ticketid, salt, hmac(recruiter))
    
#     metadata = recruiter.metadata[]

#     reply_auth_code = auth(metadata, ticketid, salt, hmac(recruiter))

#     push!(recruiter.tickets, Ticket(ticketid, timestamp, salt, reply_auth_code, _token, nothing))

#     return metadata, salt, reply_auth_code
# end



struct Invite
    demehash::Digest
    ticketid::TicketID
    token::Digest
    hasher::Hash # HashSpec
    route::URI
end

Base.:(==)(x::Invite, y::Invite) = x.demehash == y.demehash && x.ticketid == y.ticketid && x.token == y.token && x.hasher == y.hasher && x.route == y.route

# This gives a nasty error for some reason when CryptoGroups are imported.
#@batteries Invite

isbinding(spec::DemeSpec, invite::Invite) = Model.digest(spec, invite.hasher) == invite.demehash

# Parsing to string and back

hasher(invite::Invite) = invite.hasher


function enlist!(recruiter::Registrar, ticketid::TicketID, timestamp::DateTime; route=URI())

    @assert (Dates.now() - timestamp) < Second(3600) "Request too old"

    metadata = Digest(recruiter.metadata[])

    for ticket in recruiter.tickets
        if ticket.ticketid == ticketid
            if isadmitted(ticket)
                error("Ticket with $ticketid is already admitted.")
            else
                return Invite(metadata, ticketid, ticket.token, hasher(recruiter.hmac), route)
            end
        end
    end

    # Just to follow
    salt = rand(UInt8, 16) # Needs a real random number generator
    _token = token(ticketid, salt, hmac(recruiter))

    push!(recruiter.tickets, Ticket(ticketid, timestamp, salt, Digest(), _token, nothing))

    return Invite(metadata, ticketid, _token, hasher(recruiter.hmac), route)
end



"""
    admit!(recruiter::Registrar, id::Pseudonym, ticketid::TicketID, auth_code::Digest)::Admission

Attempt to admit an identity pseudonym `id` for ticket `ticketid` with provided authorization code. This function retrieves a ticket with given `ticketid` and uses it's recorded `token` to check whether the request is binding. In the case of success an admnission certificate is formed with provided indenty pseudonym `id` and is signed by the recruter's private key. Otherwise when either of checks fail an error is raised. In the case ticket is already addmitted, returns previously stored admission. 
"""
#function admit!(recruiter::Registrar, id::Pseudonym, ticketid::TicketID, auth_code::Digest)
function admit!(recruiter::Registrar, id::Pseudonym, ticketid::TicketID) # ticketid is the authorization
    
    N = findfirst(x -> x.ticketid == ticketid, recruiter.tickets)
    isnothing(N) && error("Ticket not found")

    ticket = recruiter.tickets[N]

    #@assert isbinding(id, auth_code, token(ticket, hmac(recruiter)), hasher(recruiter))

    if isnothing(ticket.admission)

        admission_draft = Admission(ticket.ticketid, id, ticket.timestamp)
        ticket.admission = approve(admission_draft, recruiter.signer)
        
        # Closing admission. Salt is set empty as indication 
        # When updating metadata the full list of tickets needs to be updated.
        # Note that unused admissions can be erassed if a new generator is being set thourhg braiding
        # To invalidate this cancellation message metadata could also contain a hash of 
        # the current state generator or index at which unused amdissions had been erased

        #ticket.salt = UInt8[]
        #ticket.auth_code = auth(recruiter.metadata[], ticketid, ticket.salt, hmac(recruiter))

        #ticket.token = token(ticketid, ticket.salt, hmac(recruiter))
    end

    return ticket.admission
end

"""
    isadmitted(ticketid::TicketID, recruiter::Registrar)

Check whether a ticket is already admitted. Returns false when either ticket is nonexistent or it's admission is nothing.
"""
function isadmitted(ticketid::TicketID, recruiter::Registrar)

    admission = select(Admission, ticketid, recruiter)

    if isnothing(admission)
        return false
    else
        return true
    end
end

unpack(x::Vector) = length(x) == 0 ? nothing : x[1]
unpack(x::Nothing) = nothing


"""
struct TicketStatus
    ticketid::TicketID
    timestamp::DateTime
    admission::Union{Nothing, Admission}
end
    
Represents a public state of a ticket. See [`ticket_status`](@ref) and [`isadmitted`](@ref) methods. 
"""
struct TicketStatus
    ticketid::TicketID
    timestamp::DateTime
    admission::Union{Nothing, Admission}
end

"""
    ticket_status(ticketid::TicketID, recruiter::Registrar)::Union{TicketStatus, Nothing}

Return a ticket status for a ticketid. In case ticket is not found return nothing.
"""
function ticket_status(ticketid::TicketID, recruiter::Registrar)

    ticket = select(Ticket, ticketid, recruiter)
    
    if isnothing(ticket)
        return nothing
    else
        return TicketStatus(ticketid, ticket.timestamp, ticket.admission)
    end
end

"""
    isadmitted(status::TicketStatus)

Check whether ticket is addmitted. 
"""
isadmitted(status::TicketStatus) = !isnothing(status.admission)
